@page "/catan"
@using Catan.Shared.Model.GameState.Dice;
@using Catan.Shared.Model.GameState;
@using Microsoft.AspNetCore.SignalR.Client
@using System.Text.Json.Serialization;
@using Catan.Shared.Model.GameMap;
@inject NavigationManager Navigation
@implements IAsyncDisposable
@inject IJSRuntime JS
@inject HttpClient Http


<PageTitle>Catan</PageTitle>

<div id="CatanPage" class="p-0">
	<div class="container-fluid">
		<div class="row">
			<div class="col-md-2 d-flex flex-column">
				@*PLAYERS INFOS*@
				@foreach (var player in PlayerList) 
				{
					if (player.Name == CurrentPlayerName)
					{
						<div class="p-2 px-4">
							<div class="card h-100 border-dark PlayerCard">
								<div class="card-header" style="background-color:@player.Color;min-height:50px; border-color:yellow; border:solid;"></div>
								<div class="card-body">
									@player.Name <br>
									points: @player.Points <br>
									resources: @(inventory.Values.Sum())
									cards: @(cardInventory.Values.Sum())
								</div>
							</div>
						</div>
					}
					else
					{
						<div class="p-2 px-4">
							<div class="card h-100 border-dark PlayerCard">
								<div class="card-header" style="background-color:@player.Color;min-height:50px;"></div>
								<div class="card-body">
									@player.Name <br>
									points: @player.Points <br>
									resources: @(nameResourceCount.GetValueOrDefault(player.Name!))
									cards: @(nameCardCount.GetValueOrDefault(player.Name!))
								</div>
							</div>
						</div>
					}
				}
				<div class="mt-auto"> @*INVENTORY*@
					<div class="d-flex flex-row justify-content-evenly" style="background-color:rgb(250,227,144);opacity:0.8;">
						@foreach (var inventoryElement in inventory)
						{
							<div>
								<span style="min-width:12px">
									@inventoryElement.Value.ToString()
								</span>
								@switch (inventoryElement.Key)
								{
									case Resources.Wood:
										<img src="/images/resources/wood.png" width="35" height="35" />
										break;
									case Resources.Brick:
										<img src="/images/resources/brick.png" width="35" height="35" />
										break;
									case Resources.Wheat:
										<img src="/images/resources/wheat.png" width="35" height="35" />
										break;
									case Resources.Ore:
										<img src="/images/resources/ore.png" width="35" height="35" />
										break;
									case Resources.Sheep:
										<img src="/images/resources/sheep.png" width="35" height="35" />
										break;
								}
							</div>
						}
					</div>
					<div class="d-flex flex-row justify-content-evenly" style="background-color:rgb(250,227,144);opacity:0.8;">
						@foreach (var inventoryElement in cardInventory)
						{
							<div>
								<span style="min-width:12px">
									@inventoryElement.Value.ToString()
								</span>
								@switch (inventoryElement.Key)
								{
									case CardType.Knight:
										<img src="/images/resources/knight.png" width="35" height="35" />
										break;
									case CardType.ExtraPoint:
										<img src="/images/resources/plusone.png" width="35" height="35" />
										break;
									case CardType.RoadBuilder:
										<img src="/images/resources/roadbuilder.png" width="35" height="35" />
										break;
								}
							</div>
						}
					</div>
				</div>
			</div>
			<div class="col-md-7"> @*MAP*@
				<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="940" xmlns:xlink="http://www.w3.org/1999/xlink">
					@*PATTERNS*@
					<defs> 
						@foreach (var hexagon in hexagons)
						{
							if (hexagonSize==80)
							{
								var x = hexagon.Base.X + hexagonSize * Math.Sqrt(3) - 60.4;
								var y = hexagon.Base.Y + hexagonSize - 1;
								switch (hexagon.Field.Type)
								{
									case TerrainType.Desert:
										<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
											<image width="162" height="162" xlink:href="/images/tiles/desert.png"></image>
										</pattern>
										break;
									case TerrainType.Unknown:
										<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
											<image width="162" height="162" xlink:href="/images/tiles/fog.png"></image>
										</pattern>
										break;
									case TerrainType.GoldField:
										<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
											<image width="162" height="162" xlink:href="/images/tiles/goldfield.png"></image>
										</pattern>
										break;
									case TerrainType.Cropfield:
										<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
											<image width="162" height="162" xlink:href="/images/tiles/wheat.png"></image>
										</pattern>
										break;
									case TerrainType.Forest:
										<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
											<image width="162" height="162" xlink:href="/images/tiles/forest.png"></image>
										</pattern>
										break;
									case TerrainType.Mountains:
										<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
											<image width="162" height="162" xlink:href="/images/tiles/mountains.png"></image>
										</pattern>
										break;
									case TerrainType.Quarry:
										<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
											<image width="162" height="162" xlink:href="/images/tiles/quarry.png"></image>
										</pattern>
										break;
									case TerrainType.Grassland:
										<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
											<image width="162" height="162" xlink:href="/images/tiles/grassland.png"></image>
										</pattern>
										break;
									case TerrainType.Sea:
										<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
											<image width="162" height="162" xlink:href="/images/tiles/sea.png"></image>
										</pattern>
										break;
								}
							}
							else
							{
								var x = hexagon.Base.X + hexagonSize * Math.Sqrt(3) - 40;
								var y = hexagon.Base.Y + hexagonSize - 1;
								switch (hexagon.Field.Type)
								{
									case TerrainType.Desert:
										<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
											<image width="110" height="110" xlink:href="/images/tiles/desert.png"></image>
										</pattern>
										break;
									case TerrainType.Unknown:
										<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
											<image width="110" height="110" xlink:href="/images/tiles/fog.png"></image>
										</pattern>
										break;
									case TerrainType.GoldField:
										<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
											<image width="110" height="110" xlink:href="/images/tiles/goldfield.png"></image>
										</pattern>
										break;
									case TerrainType.Cropfield:
										<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
											<image width="110" height="110" xlink:href="/images/tiles/wheat.png"></image>
										</pattern>
										break;
									case TerrainType.Forest:
										<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
											<image width="110" height="110" xlink:href="/images/tiles/forest.png"></image>
										</pattern>
										break;
									case TerrainType.Mountains:
										<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
											<image width="110" height="110" xlink:href="/images/tiles/mountains.png"></image>
										</pattern>
										break;
									case TerrainType.Quarry:
										<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
											<image width="110" height="110" xlink:href="/images/tiles/quarry.png"></image>
										</pattern>
										break;
									case TerrainType.Grassland:
										<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
											<image width="110" height="110" xlink:href="/images/tiles/grassland.png"></image>
										</pattern>
										break;
									case TerrainType.Sea:
										<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
											<image width="110" height="110" xlink:href="/images/tiles/sea.png"></image>
										</pattern>
										break;
								}
							}
						}
					</defs>
					@*HEXAGONS*@
					@foreach (var hexagon in hexagons)
					{
						<polygon points=@hexagon.VerticesToString() fill="url('#@hexagons.IndexOf(hexagon)')" 
								@onclick="()=>ClickOnHexagon(hexagon.Field.Id)" stroke="black" stroke-width="1"></polygon>
						@if (hexagon.Field.Type != TerrainType.Desert && hexagon.Field.Type != TerrainType.Sea && hexagon.Field.Type!=TerrainType.Unknown)
						{
							if (hexagonSize==80)
							{
								<circle cx="@DoubleToString(hexagon.Base.X)" cy="@DoubleToString(hexagon.Base.Y)" r="25" fill="beige" />
								<text>
									<text x="@DoubleToString(hexagon.Base.X)" y="@DoubleToString(hexagon.Base.Y+12.5)" font-size="2em"
										  fill="black" text-anchor="middle">@hexagon.Field.Number</text>
								</text>
							}
							else
							{
								<circle cx="@DoubleToString(hexagon.Base.X)" cy="@DoubleToString(hexagon.Base.Y)" r="15" fill="beige" />
								<text>
									<text x="@DoubleToString(hexagon.Base.X)" y="@DoubleToString(hexagon.Base.Y+6.5)" font-size="1.2em"
										  fill="black" text-anchor="middle">@hexagon.Field.Number</text>
								</text>
							}
						}
						@if (hexagon.Field.IsRobbed)
						{
							if (hexagonSize==80)
							{
								<circle cx="@DoubleToString(hexagon.Base.X-30)" cy="@DoubleToString(hexagon.Base.Y)" r="15" fill="black" />
							}
							else
							{
								<circle cx="@DoubleToString(hexagon.Base.X-30)" cy="@DoubleToString(hexagon.Base.Y)" r="8" fill="black" />
							}
						}
					}
					@*CORNER PLACEHOLDERS*@
					@foreach (var cornerCircle in cornerCircles)
					{
						if (cornerCircle.Corner.Level == 0)
						{
							if (makingSettlement)
							{
								<circle class="cornerCircle" cx="@DoubleToString(cornerCircle.BaseVertex.X)" cy="@DoubleToString(cornerCircle.BaseVertex.Y)" r="10"
							@onclick="()=>ClickOnCornerCircle(cornerCircle.Corner.Id)" fill="black" fill-opacity="0" stroke="green" stroke-width="2" stroke-opacity="0.9" />
							}
							else
							{
								<circle class="cornerCircle" cx="@DoubleToString(cornerCircle.BaseVertex.X)" cy="@DoubleToString(cornerCircle.BaseVertex.Y)" r="10"
							@onclick="()=>ClickOnCornerCircle(cornerCircle.Corner.Id)" fill="black" fill-opacity="0"/>
							}
						}
						if (cornerCircle.Corner.Level == 1)
						{
							if (makingCity)
							{
								<circle class="cornerCircle" cx="@DoubleToString(cornerCircle.BaseVertex.X)" cy="@DoubleToString(cornerCircle.BaseVertex.Y)" r="10"
								@onclick="()=>ClickOnCornerCircle(cornerCircle.Corner.Id)" fill="@cornerCircle.Corner.Player.Color" fill-opacity="1" stroke="green" stroke-width="2" stroke-opacity="0.9" />
							}
							<polyline points=@cornerCircle.GetSettlementString() fill="@cornerCircle.Corner.Player.Color" fill-opacity="1" stroke="black" stroke-width="1" stroke-opacity="0.9" />
							<circle class="cornerCircle" cx="@DoubleToString(cornerCircle.BaseVertex.X)" cy="@DoubleToString(cornerCircle.BaseVertex.Y)" r="10"
							@onclick="()=>ClickOnCornerCircle(cornerCircle.Corner.Id)" fill="@cornerCircle.Corner.Player.Color" fill-opacity="0"/>
						}
						else if (cornerCircle.Corner.Level == 2)
						{
							<polyline points=@cornerCircle.GetCityString() fill="@cornerCircle.Corner.Player.Color" fill-opacity="1" stroke="black" stroke-width="1" stroke-opacity="0.9" />
							<circle class="cornerCircle" cx="@DoubleToString(cornerCircle.BaseVertex.X)" cy="@DoubleToString(cornerCircle.BaseVertex.Y)" r="10"
							@onclick="()=>ClickOnCornerCircle(cornerCircle.Corner.Id)" fill="@cornerCircle.Corner.Player.Color" fill-opacity="0" />
						}
					}
					@*EDGE PLACEHOLDERS*@
					@foreach (var edgeLine in edgeLines)
					{
						if (edgeLine.Edge.Owner.Name is not null)
						{
							if (edgeLine.Edge.EdgeType==EdgeType.Road)
							{
								<polygon points=@edgeLine.VerticesToString() fill="@edgeLine.Edge.Owner.Color" fill-opacity="1" stroke="black" stroke-width="1" stroke-opacity="0.9"
								@onclick="()=>ClickOnEdgeLine(edgeLine.Edge.Id)" />
							}
							if (edgeLine.Edge.EdgeType==EdgeType.Ship)
							{
								<polygon points=@edgeLine.VerticesToString() fill="@edgeLine.Edge.Owner.Color" fill-opacity="1" stroke="black" stroke-width="1" stroke-opacity="0.9"
								@onclick="()=>ClickOnEdgeLine(edgeLine.Edge.Id)" />
							}
							
						}
						else
						{
							if (makingRoad || makingShip)
							{
								<polygon points=@edgeLine.VerticesToString() fill="black" fill-opacity="0" stroke="green" stroke-width="2" stroke-opacity="0.9"
							 @onclick="()=>ClickOnEdgeLine(edgeLine.Edge.Id)" />
							}
							else
							{
								<polygon points=@edgeLine.VerticesToString() fill="black" fill-opacity="0" @onclick="()=>ClickOnEdgeLine(edgeLine.Edge.Id)" />
							}
						}
					}
				</svg>
			</div>
			<div class="col-md-3"> 
				<div class="flex-column justify-content-between">
					<div class="m-3 p-3"> @*CHAT*@
						<div id="chatSpace">
							<Chat @ref=ChatComponent />
						</div>
					</div>
					<div class="m-3 p-3"> @*COSTS*@
						<table id="BuildCost" width="100%">
							<tr>
								<td colspan="2" style="text-align:center;">Building Costs</td>
							</tr>
							@if (map is not null && map.FieldList.Count>37)
							{
								<tr @onclick="async () => await BuildingShipClicked()">
									<td> Ship:</td>
									<td>
										<img src="/images/resources/sheep.png" width="40" height="40" />
										<img src="/images/resources/wood.png" width="40" height="40" />
									</td>
								</tr>
							}
							<tr @onclick="async () => await BuildingRoadClicked()">
								<td> Road:</td>
								<td>
									<img src="/images/resources/wood.png" width="40" height="40" />
									<img src="/images/resources/brick.png" width="40" height="40" />
								</td>
							</tr>
							<tr @onclick="async () => await BuildingSettlementClicked()">
								<td>Settlement:</td>
								<td>
									<img src="/images/resources/wood.png" width="40" height="40" />
									<img src="/images/resources/brick.png" width="40" height="40" />
									<img src="/images/resources/sheep.png" width="40" height="40" />
									<img src="/images/resources/wheat.png" width="40" height="40" />
								</td>
							</tr>
							<tr  @onclick="async () => await BuildingCityClicked()" > 
								<td>City:</td>
								<td>
									<img src="/images/resources/wheat.png" width="40" height="40" />
									<img src="/images/resources/wheat.png" width="40" height="40" />
									<img src="/images/resources/ore.png" width="40" height="40" />
									<img src="/images/resources/ore.png" width="40" height="40" />
									<img src="/images/resources/ore.png" width="40" height="40" />
								</td>
							</tr>
							<tr>
								<td>Development Card:</td>
								<td>
									<img src="/images/resources/wheat.png" width="40" height="40" />
									<img src="/images/resources/ore.png" width="40" height="40" />
									<img src="/images/resources/sheep.png" width="40" height="40" />
								</td>
							</tr>
						</table>
					</div>
					<div class="d-flex flex-row-reverse m-3 p-3" style="min-height:100px;"> @*DICES*@
						@foreach (var dice in dices)
						{
							switch (dice)
							{
								case 1:
									<img src="/images/dice/dice1.png" width="80" height="80" />
									break;
								case 2:
									<img src="/images/dice/dice2.png" width="80" height="80" />
									break;
								case 3:
									<img src="/images/dice/dice3.png" width="80" height="80" />
									break;
								case 4:
									<img src="/images/dice/dice4.png" width="80" height="80" />
									break;
								case 5:
									<img src="/images/dice/dice5.png" width="80" height="80" />
									break;
								case 6:
									<img src="/images/dice/dice6.png" width="80" height="80" />
									break;
							}
						}
					</div>
					<div class="d-flex flex-row-reverse m-3 p-3"> @* BUTTONS *@
						<div class="p-2">
							<button @onclick="EndTurn" disabled="@(!CanEndTurn())" style="margin:0px;border:0px;padding:0px;"> <img width="60" height="60" src="/images/dice/endturn.png" style="background-color:rgb(250,227,144);" /> </button>
						</div>
						<div class="p-2">
							<button @onclick="RollDice" disabled="true" style="margin:0px;border:0px;padding:0px;"> <img width="60" height="60" src="/images/dice/cards.png" style="background-color:rgb(250,227,144);" /> </button>
						</div>
						<div class="p-2">
							<button @onclick="EndTurn" disabled="true" style="margin:0px;border:0px;padding:0px;"> <img width="60" height="60" src="/images/dice/trade.png" style="background-color:rgb(250,227,144);" /> </button>
						</div>
						<div class="p-2">
							<button @onclick="RollDice" disabled="@(!CanRollDice())" style="margin:0px;border:0px;padding:0px;"> <img width="60" height="60" src="/images/dice/rolldices.png" style="background-color:rgb(250,227,144);" /> </button>
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>

<div> @*TRADEOFFERS*@
	<table> 
		@foreach (var tradeoffer in tradeOffers)
		{
			<tr>
				<td>
					<table>
						<tr>
							<td colspan="5"> @(tradeoffer.Owner.Name)'s offer </td>
						</tr>
						<tr>
							<td><img src="/images/resources/brick.png" width="35" height="35" /></td>
							<td><img src="/images/resources/ore.png" width="35" height="35" /></td>
							<td><img src="/images/resources/sheep.png" width="35" height="35" /></td>
							<td><img src="/images/resources/wheat.png" width="35" height="35" /></td>
							<td><img src="/images/resources/wood.png" width="35" height="35" /></td>
						</tr>
						<tr>
							<td>@tradeoffer.OwnerOffer.Inventory[Resources.Brick]</td>
							<td>@tradeoffer.OwnerOffer.Inventory[Resources.Ore]</td>
							<td>@tradeoffer.OwnerOffer.Inventory[Resources.Sheep]</td>
							<td>@tradeoffer.OwnerOffer.Inventory[Resources.Wheat]</td>
							<td>@tradeoffer.OwnerOffer.Inventory[Resources.Wood]</td>
						</tr>
					</table>
				</td>
				<td>
					<table>
						<tr>
							<td colspan="5"> Your offer </td>
						</tr>
						<tr>
							<td><img src="/images/resources/brick.png" width="35" height="35" /></td>
							<td><img src="/images/resources/ore.png" width="35" height="35" /></td>
							<td><img src="/images/resources/sheep.png" width="35" height="35" /></td>
							<td><img src="/images/resources/wheat.png" width="35" height="35" /></td>
							<td><img src="/images/resources/wood.png" width="35" height="35" /></td>
						</tr>
						<tr>
							<td>@tradeoffer.TargetOffer.Inventory[Resources.Brick]</td>
							<td>@tradeoffer.TargetOffer.Inventory[Resources.Ore]</td>
							<td>@tradeoffer.TargetOffer.Inventory[Resources.Sheep]</td>
							<td>@tradeoffer.TargetOffer.Inventory[Resources.Wheat]</td>
							<td>@tradeoffer.TargetOffer.Inventory[Resources.Wood]</td>
						</tr>
					</table>
				</td>
				<td>
					<button @onclick="()=>AcceptTradeOffer(tradeoffer)">Accept</button>
				</td>
			</tr>
		}
	</table>
	<button @onclick="()=>this.creatingTradeOffer=true">Create</button>
	@if (creatingTradeOffer)
	{
		<table>
			<tr>
				<td colspan="5">Your offer</td>
			</tr>
			<tr>
				<td><label for="ownBrick"><img src="/images/resources/brick.png" width="35" height="35" /></label></td>
				<td><label for="ownOre"><img src="/images/resources/ore.png" width="35" height="35" /></label></td>
				<td><label for="ownSheep"><img src="/images/resources/sheep.png" width="35" height="35" /></label></td>
				<td><label for="ownWheat"><img src="/images/resources/wheat.png" width="35" height="35" /></label></td>
				<td><label for="ownWood"><img src="/images/resources/wood.png" width="35" height="35" /></label></td>
			</tr>
			<tr>
				<td><input type="number" id="ownBrick" name="ownBrick" min="0" @bind-value=ownerTradeOfferInventory.Inventory[Resources.Brick]><br></td>
				<td><input type="number" id="ownOre" name="ownOre" min="0" @bind-value=ownerTradeOfferInventory.Inventory[Resources.Ore]><br></td>
				<td><input type="number" id="ownSheep" name="ownSheep" min="0" @bind-value=ownerTradeOfferInventory.Inventory[Resources.Sheep]><br></td>
				<td><input type="number" id="ownWheat" name="ownWheat" min="0" @bind-value=ownerTradeOfferInventory.Inventory[Resources.Wheat]><br></td>
				<td><input type="number" id="ownWood" name="ownWood" min="0" @bind-value=ownerTradeOfferInventory.Inventory[Resources.Wood]><br></td>
			</tr>
			<tr>
				<td colspan="5">Target offer</td>
			</tr>
			<tr>
				<td><label for="targetBrick"><img src="/images/resources/brick.png" width="35" height="35" /></label></td>
				<td><label for="targetOre"><img src="/images/resources/ore.png" width="35" height="35" /></label></td>
				<td><label for="targetSheep"><img src="/images/resources/sheep.png" width="35" height="35" /></label></td>
				<td><label for="targetWheat"><img src="/images/resources/wheat.png" width="35" height="35" /></label></td>
				<td><label for="targetWood"><img src="/images/resources/wood.png" width="35" height="35" /></label></td>
			</tr>
			<tr>
				<td><input type="number" id="targetBrick" name="targetBrick" min="0" @bind-value=targetTradeOfferInventory.Inventory[Resources.Brick]><br></td>
				<td><input type="number" id="targetOre" name="targetOre" min="0" @bind-value=targetTradeOfferInventory.Inventory[Resources.Ore]><br></td>
				<td><input type="number" id="targetSheep" name="targetSheep" min="0" @bind-value=targetTradeOfferInventory.Inventory[Resources.Sheep]><br></td>
				<td><input type="number" id="targetWheat" name="targetWheat" min="0" @bind-value=targetTradeOfferInventory.Inventory[Resources.Wheat]><br></td>
				<td><input type="number" id="targetWood" name="targetWood" min="0" @bind-value=targetTradeOfferInventory.Inventory[Resources.Wood]><br></td>
			</tr>

			<button @onclick="SendTradeOffer">Send</button>
			<button @onclick="()=>this.creatingTradeOffer=false">Cancel</button>
		</table>
	}
</div>

<div> @*THROWRESOURCES*@
	@if (haveToThrowResources)
	{
		<table>
			<tr>
				<td colspan="5">Target offer</td>
			</tr>
			<tr>
				<td><label for="throwBrick"><img src="/images/resources/brick.png" width="35" height="35" /></label></td>
				<td><label for="throwOre"><img src="/images/resources/ore.png" width="35" height="35" /></label></td>
				<td><label for="throwSheep"><img src="/images/resources/sheep.png" width="35" height="35" /></label></td>
				<td><label for="throwWheat"><img src="/images/resources/wheat.png" width="35" height="35" /></label></td>
				<td><label for="throwWood"><img src="/images/resources/wood.png" width="35" height="35" /></label></td>
			</tr>
			<tr>
				<td><input type="number" id="throwBrick" name="throwBrick" min="0" @bind-value=throwResourcesInventory.Inventory[Resources.Brick]><br></td>
				<td><input type="number" id="throwOre" name="throwOre" min="0" @bind-value=throwResourcesInventory.Inventory[Resources.Ore]><br></td>
				<td><input type="number" id="throwSheep" name="throwSheep" min="0" @bind-value=throwResourcesInventory.Inventory[Resources.Sheep]><br></td>
				<td><input type="number" id="throwWheat" name="throwWheat" min="0" @bind-value=throwResourcesInventory.Inventory[Resources.Wheat]><br></td>
				<td><input type="number" id="throwWood" name="throwWood" min="0" @bind-value=throwResourcesInventory.Inventory[Resources.Wood]><br></td>
			</tr>

			<button @onclick="ThrowResources">Throw Resources</button>
		</table>
	}
</div>

<button @onclick="BuyCard"> Kártya</button>
<button @onclick="()=>makingCard=true"> play card</button>

<p>@errorMessage</p>

<div>
	<table>
		<tr>
			<td colspan="3"> Cards Inventory</td>
		</tr>
		<tr>
			<td @onclick="()=>PlayCard(CardType.Knight)">Lovag</td>
			<td @onclick="()=>PlayCard(CardType.RoadBuilder)">Ut</td>
			<td @onclick="()=>PlayCard(CardType.ExtraPoint)">+1 pont</td>
		</tr>
		<tr>
			<td>@cardInventory[CardType.Knight]</td>
			<td>@cardInventory[CardType.RoadBuilder]</td>
			<td>@cardInventory[CardType.ExtraPoint]</td>
		</tr>
	</table>
</div>


@code {
	private int CalculatePatternWidth()
	{
		return ((hexagonSize + 1) * 2);
	}
	private int CalculatePatternHeight()
	{
		return ((hexagonSize + 1) * 2);
	}

	private AbstractInventory throwResourcesInventory = new AbstractInventory();

	private AbstractInventory ownerTradeOfferInventory = new AbstractInventory();
	private AbstractInventory targetTradeOfferInventory = new AbstractInventory();
	private bool makingSettlement = false;
	private bool makingRoad = false;
	private bool makingCity = false;
	private bool makingShip = false;
	private bool makingCard = false;


	private bool ownTurn = false;
	private bool diceRolled = false;
	public bool IsConnected =>
		hubConnection?.State == HubConnectionState.Connected;

	private Chat? ChatComponent { get; set; }

	List<Hexagon> hexagons = new List<Hexagon>();

	List<CornerCircle> cornerCircles = new List<CornerCircle>();

	List<EdgeLine> edgeLines = new List<EdgeLine>();

	private int hexagonSize = 80;
	private int hexagonStartingX = 280;
	private int hexagonStartingY = 140;

	private string Guid = "";

	private HubConnection? hubConnection;

	private Map? map;

	private Actor? actor;

	private Dictionary<Resources, int> inventory = new Dictionary<Resources, int>
		{
			{ Resources.Brick, 0 },
			{ Resources.Ore, 0 },
			{ Resources.Sheep, 0 },
			{ Resources.Wheat, 0 },
			{ Resources.Wood, 0 }
		};

	private string CurrentPlayerName = "";
	public void SetYourTurn()
	{
		ownTurn = true;
		diceRolled = false;
		StateHasChanged();
	}
	private async Task BuildingShipClicked()
	{
		makingShip = true;
		StateHasChanged();
		await Task.Delay(5000);
		makingShip = false;
		StateHasChanged();
	}
	private async Task BuildingRoadClicked()
	{
		makingRoad=true;
		StateHasChanged();
		await Task.Delay(5000);
		makingRoad=false;
		StateHasChanged();
	}
	private async Task BuildingSettlementClicked()
	{
		makingSettlement = true;
		StateHasChanged();
		await Task.Delay(5000);
		makingSettlement = false;
		StateHasChanged();
	}
	private async Task BuildingCityClicked()
	{
		makingCity = true;
		StateHasChanged();
		await Task.Delay(5000);
		makingCity = false;
		StateHasChanged();
	}
	protected override async Task OnInitializedAsync()
	{
		string name = await JS.InvokeAsync<string>("localStorage.getItem", "userName");
		Guid = await JS.InvokeAsync<string>("localStorage.getItem", "GameGuid");
		string token = await JS.InvokeAsync<string>("localStorage.getItem", "loginToken");
		actor = new Actor(name,token);
		hubConnection = new HubConnectionBuilder()
			.WithUrl(Navigation.ToAbsoluteUri("/gamehub"), options =>
			{
				options.AccessTokenProvider = async () =>
				{
					var token = await JS.InvokeAsync<string>("localStorage.getItem", "loginToken");
					return token;
				};
			})
			.AddJsonProtocol(options =>
			{
				options.PayloadSerializerOptions.ReferenceHandler=ReferenceHandler.IgnoreCycles;
				options.PayloadSerializerOptions.IncludeFields = true;
			})
			.Build();

		SetupHubConnectionEndpoints();

		//Start hub connection
		await hubConnection.StartAsync();
		//Join the correct game group
		await hubConnection.InvokeAsync("JoinGroup", Guid);
		//Setting the connection string at server side
		await SetConnectionString(hubConnection.ConnectionId!);
		//GetMap from server
		var response = await hubConnection!.InvokeAsync<Map>("GetMap", Guid, CancellationToken.None);
		await updateMapStatus(response);
		//Change the group of the chat
		await ChatComponent!.ChangeSignalRGroup(Guid);

	}
	private List<Player> PlayerList = new List<Player>();
	private Dictionary<string, int> nameResourceCount = new Dictionary<string, int>();
	private Dictionary<string, int> nameCardCount = new Dictionary<string, int>();
	private Dictionary<CardType, int> cardInventory = new Dictionary<CardType, int>
	{
		{CardType.Knight,0},
		{CardType.RoadBuilder,0},
		{CardType.ExtraPoint,0}
	};
	private async Task UpdatePlayerList()
	{
		var response = await hubConnection!.InvokeAsync<List<Player>>("GetPlayerList", actor, Guid);
		PlayerList = response;
	}
	private async Task updateMapStatus(Map newMap)
	{
		map = newMap;
		hexagons.Clear();
		cornerCircles.Clear();
		edgeLines.Clear();
		CreateHexagonMap(map.FieldList);
		CreateHexagonEdges();
		CreateCornerCircles();

		await UpdatePlayerList();

		StateHasChanged();
	}
	private string DoubleToString(double d)
	{
		return d.ToString(CultureInfo.InvariantCulture);
	}
	private void CreateHexagonMap(List<Field> fields)
	{
		if (fields.Count==37)
		{
			hexagonStartingX = 280;
			hexagonStartingY = 140;
			hexagonSize = 80;
			for (int i = 0; i < 4; i++)
			{
				hexagons.Add(new Hexagon(hexagonStartingX + i * hexagonSize * Math.Sqrt(3), hexagonStartingY, hexagonSize, fields[i]));
			}
			for (int i = 0; i < 5; i++)
			{
				hexagons.Add(new Hexagon(hexagons[0].vertices[2].X + i * hexagonSize * Math.Sqrt(3), hexagons[0].vertices[2].Y + hexagonSize, hexagonSize, fields[i + 4]));
			}
			for (int i = 0; i < 6; i++)
			{
				hexagons.Add(new Hexagon(hexagons[4].vertices[2].X + i * hexagonSize * Math.Sqrt(3), hexagons[4].vertices[2].Y + hexagonSize, hexagonSize, fields[i + 9]));
			}
			for (int i = 0; i < 7; i++)
			{
				hexagons.Add(new Hexagon(hexagons[9].vertices[2].X + i * hexagonSize * Math.Sqrt(3), hexagons[9].vertices[2].Y + hexagonSize, hexagonSize, fields[i + 15]));
			}
			for (int i = 0; i < 6; i++)
			{
				hexagons.Add(new Hexagon(hexagons[15].vertices[0].X + i * hexagonSize * Math.Sqrt(3), hexagons[15].vertices[0].Y + hexagonSize, hexagonSize, fields[i + 22]));
			}
			for (int i = 0; i < 5; i++)
			{
				hexagons.Add(new Hexagon(hexagons[22].vertices[0].X + i * hexagonSize * Math.Sqrt(3), hexagons[22].vertices[0].Y + hexagonSize, hexagonSize, fields[i + 28]));
			}
			for (int i = 0; i < 4; i++)
			{
				hexagons.Add(new Hexagon(hexagons[28].vertices[0].X + i * hexagonSize * Math.Sqrt(3), hexagons[28].vertices[0].Y + hexagonSize, hexagonSize, fields[i + 33]));
			}
		}
		else
		{
			hexagonSize = 54;
			hexagonStartingX = 60;
			hexagonStartingY = 140;
			//első sor van előrébb
			for (int i = 0; i < 10; i++)
			{
				hexagons.Add(new Hexagon(hexagonStartingX + i * hexagonSize * Math.Sqrt(3), hexagonStartingY, hexagonSize, fields[i]));
			}
			for (int i = 1; i < 9; i++)
			{
				for (int j = 0; j < 10; j++)
				{
					if (i % 2 == 0) 
					{
						hexagons.Add(new Hexagon(hexagons[(i - 1) * 10].vertices[2].X + j * hexagonSize * Math.Sqrt(3), hexagons[(i - 1) * 10].vertices[2].Y + hexagonSize, hexagonSize, fields[i * 10 + j]));
					}
					else
					{
						hexagons.Add(new Hexagon(hexagons[(i - 1) * 10].vertices[0].X + j * hexagonSize * Math.Sqrt(3), hexagons[(i - 1) * 10].vertices[0].Y + hexagonSize, hexagonSize, fields[i * 10 + j]));
					}

				}
			}
		}
	}
	private void CreateHexagonEdges()
	{
		for (int i = 0; i < hexagons.Count; i++)
		{
			for (int j = 0; j < 6; j++)
			{
				Edge tmpEdge = hexagons[i].Field.Edges[j];
				edgeLines.Add(new EdgeLine(hexagons[i].vertices[j], hexagons[i].vertices[(j + 1) % 6], tmpEdge));
			}
		}
	}
	private void CreateCornerCircles()
	{
		for (int i = 0; i < hexagons.Count; i++)
		{
			for (int j = 0; j < 6; j++)
			{
				Corner tmpCorner = hexagons[i].Field.Corners[j];
				cornerCircles.Add(new CornerCircle(hexagons[i].vertices[j], tmpCorner));
			}
		}
	}
	public async ValueTask DisposeAsync()
	{
		if (hubConnection is not null)
		{
			await hubConnection.DisposeAsync();
		}
	}

	private bool haveToThrowResources = false;
	private string errorMessage = "";
	private bool resolveSevenOrMoreResources = false;
	private bool resolveRobberMovement = false;
	private bool creatingTradeOffer = false;
	private bool initialVillageTurn = false; //TODO use
	private bool initialRoadTurn = false; //TODO use

	private async Task ThrowResources()
	{
		if (HasSufficientResources(throwResourcesInventory))
		{
			await hubConnection!.SendAsync("ThrowResources", actor, Guid, throwResourcesInventory);
		}
		else
		{
			errorMessage = "Not enough resources";
		}
	}


	private void SetupHubConnectionEndpoints()
	{
		hubConnection!.On("FetchCards", async () =>
		{
			var response = await hubConnection!.InvokeAsync<FetchCardInventoryDTO?>("GetCards", actor, Guid);
			if (response is not null)
			{
				foreach (var dictionaryItem in response.CardInventory)
				{
					cardInventory[dictionaryItem.Key] = dictionaryItem.Value;
				}
				nameCardCount = response.OthersInventory;
				StateHasChanged();
			}
		});
		hubConnection!.On<Map>("ProcessMap", async (map) =>
		{
			await updateMapStatus(map);
		});
		hubConnection!.On("ResolveSevenRoll", () =>
		{
			resolveSevenOrMoreResources = true;
			haveToThrowResources = true;
			StateHasChanged();
		});
		hubConnection!.On("ResourcesThrown", () =>
		{
			haveToThrowResources = false;
			throwResourcesInventory = new AbstractInventory();
			StateHasChanged();
		});
		hubConnection!.On("SevenRollResolved", () =>
		{
			resolveSevenOrMoreResources = false;
			StateHasChanged();
		});
		hubConnection!.On("ResolveRobberMovement", () =>
		{
			resolveRobberMovement = true;
			StateHasChanged();
		});
		hubConnection!.On("RobberMovementResolved", () =>
		{
			resolveRobberMovement = false;
			StateHasChanged();
		});
		hubConnection!.On("InitialTurnDone", () =>
		{
			initialRoadTurn = false;
			StateHasChanged();
		});
		hubConnection!.On("PlaceInitialVillage", () =>
		{
			initialVillageTurn = true;
			StateHasChanged();
		});
		hubConnection!.On("PlaceInitialRoad", () =>
		{
			initialRoadTurn = true;
			initialVillageTurn = false;
			StateHasChanged();
		});
		hubConnection!.On("TakeNormalTurn", () =>
		{
			diceRolled = false;
			ownTurn = true;
			StateHasChanged();
		});
		hubConnection!.On<string>("ProcessCurrentPlayer", name =>
		{
			CurrentPlayerName = name;
			StateHasChanged();
		});

		hubConnection!.On<string>("ProcessErrorMessage", message =>
		{
			errorMessage = message;
			StateHasChanged();
		});

		hubConnection!.On("FetchResources", async () =>
		{
			var response = await hubConnection!.InvokeAsync<FetchInventoryDTO>("GetPlayersInventories", actor, Guid);
			foreach (var dictionaryItem in response.Inventory)
			{
				inventory[dictionaryItem.Key] = dictionaryItem.Value;
			}
			nameResourceCount = response.OthersInventory;
			StateHasChanged();
		});

		hubConnection!.On("ProcessDiceRolled", async () =>
		{
			var response = await hubConnection!.InvokeAsync<int[]>("GetLatestRolledBaseDices", Guid);
			if (response is null)
			{
				throw new Exception("WTF");
			}
			dices[0] = response[0];
			dices[1] = response[1];
			StateHasChanged();
		});
		hubConnection!.On("DiceRolled", () =>
		{
			diceRolled = true;
			StateHasChanged();
		});
		hubConnection!.On("TurnEnded", () =>
		{
			ownTurn = false;
			StateHasChanged();
		});
		hubConnection!.On("GameOver", () =>
		{
			//TODO 
		});
		hubConnection!.On("FetchTradeOffers", async () =>
		{
			var response = await hubConnection!.InvokeAsync<List<TradeOffer>?>("GetTradeOffers", Guid);
			if (response is not null)
			{
				tradeOffers = response;
			}	
			StateHasChanged();
		});

	}
	private List<TradeOffer> tradeOffers = new List<TradeOffer>();

	private bool HasSufficientResources(AbstractInventory _inventory)
	{
		if (_inventory.GetResourceCount(Resources.Wood) > inventory[Resources.Wood]) return false;
		if (_inventory.GetResourceCount(Resources.Brick) > inventory[Resources.Brick]) return false;
		if (_inventory.GetResourceCount(Resources.Ore) > inventory[Resources.Ore]) return false;
		if (_inventory.GetResourceCount(Resources.Sheep) > inventory[Resources.Wheat]) return false;
		if (_inventory.GetResourceCount(Resources.Wheat) > inventory[Resources.Wheat]) return false;
		return true;
	}

	private async Task AcceptTradeOffer(TradeOffer tradeOffer)
	{
		await hubConnection!.SendAsync("AcceptTradeOffer", actor, Guid, tradeOffer);
	}
	private async Task SendTradeOffer()
	{
		if (HasSufficientResources(ownerTradeOfferInventory))
		{
			var tradeOffer = new TradeOffer(PlayerList.First(p => p.Name == actor.Name), ownerTradeOfferInventory, targetTradeOfferInventory);
			await hubConnection!.SendAsync("SendTradeOffer", actor, Guid, tradeOffer);
			creatingTradeOffer = false;
			ownerTradeOfferInventory = new AbstractInventory();
			targetTradeOfferInventory = new AbstractInventory();
		}
		else
		{
			errorMessage = "Not enough resources";
		}
	}
	private int[] dices = new int[2];
	private async Task SetConnectionString(string conID)
	{
		await hubConnection!.SendAsync("SaveConnectionId", actor, conID, Guid);
	}
	private async Task RollDice()
	{
		await hubConnection!.SendAsync("RollDices", actor, Guid);
	}
	private async Task EndTurn()
	{
		await hubConnection!.SendAsync("EndPlayerTurn", actor, Guid);
	}
	private async Task ClickOnCornerCircle(int id)
	{
		if (initialVillageTurn)
		{
			if (makingSettlement)
			{
				await hubConnection!.SendAsync("BuildInitialVillage", actor, Guid, id);
				makingSettlement = false;
			}
		}
		else if (ownTurn)
		{
			if (makingSettlement)
			{
				await hubConnection!.SendAsync("BuildVillage", actor, Guid, id);
				makingSettlement = false;
			}
			if (makingCity)
			{
				await hubConnection!.SendAsync("BuildCity",actor,Guid,id);
				makingCity = false;
			}
		}
		StateHasChanged();
	}
	private async Task ClickOnEdgeLine(int id)
	{
		if (initialRoadTurn)
		{
			if (makingRoad)
			{
				await hubConnection!.SendAsync("BuildInitialRoad", actor, Guid, id);
				makingRoad = false;
			}
			if (makingShip)
			{
				await hubConnection!.SendAsync("BuildInitialShip", actor, Guid, id);
				makingShip = false;
			}
		}
		else if (ownTurn)
		{
			if (makingRoad)
			{
				await hubConnection!.SendAsync("BuildRoad", actor, Guid, id);
				makingRoad = false;
			}
			if (makingShip)
			{
				await hubConnection!.SendAsync("BuildShip", actor, Guid, id);
				makingShip = false;
			}
		}
		StateHasChanged();
	}
	private async Task ClickOnHexagon(int id)
	{
		if (ownTurn)
		{
			await hubConnection!.SendAsync("MoveRobber", actor, Guid, id);
		}
	}
	private bool CanRollDice()
	{
		if (diceRolled)
		{
			return false;
		}
		if (ownTurn)
		{
			return true;
		}
		return false;
	}
	private bool CanEndTurn()
	{
		if (!diceRolled)
		{
			return false;
		}
		if (resolveSevenOrMoreResources || resolveRobberMovement)
		{
			return false;
		}
		if (ownTurn)
		{
			return true;
		}
		return false;
	}

	private async Task BuyCard()
	{
		await hubConnection!.SendAsync("BuyCard", actor, Guid);
	}
	private async Task PlayCard(CardType card)
	{
		if (makingCard)
		{
			await hubConnection!.SendAsync("PlayCard", actor, Guid, card);
		}
	}
}