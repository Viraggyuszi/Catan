@page "/catan"
@using Microsoft.AspNetCore.SignalR.Client
@using System.Text.Json.Serialization;
@inject NavigationManager Navigation
@implements IAsyncDisposable
@inject IJSRuntime JS
@inject HttpClient Http


<PageTitle>Catan</PageTitle>

<div id="CatanPage" class="p-0">
	<div class="container-fluid">
		<div class="row">
			<div class="col-md-2 d-flex flex-column">
				
				@foreach (var player in PlayerList)
				{
					if (player.Name == actor.Name)
					{
						<div class="p-2 px-4">
							<div class="card h-100 border-dark PlayerCard">
								<div class="card-header" style="background-color:@player.Color;min-height:50px;"></div>
								<div class="card-body">
									@player.Name <br>
									points: @player.Points <br>
									resources: @(inventory.Values.Sum())
								</div>
							</div>
						</div>
					}
					else
					{
						<div class="p-2 px-4">
							<div class="card h-100 border-dark PlayerCard">
								<div class="card-header" style="background-color:@player.Color;opacity:0.5;min-height:50px;"></div>
								<div class="card-body">
									@player.Name <br>
									points: @player.Points <br>
									resources: @(nameResourceCount.GetValueOrDefault(player.Name!))
								</div>
							</div>
						</div>
					}
				}
				<div class="mt-auto">
					<div class="d-flex flex-row justify-content-evenly" style="background-color:rgb(250,227,144);opacity:0.8;">
						@foreach (var inventoryElement in inventory)
						{
							<div>
								<span style="min-width:12px">
									@inventoryElement.Value.ToString()
								</span>
								@switch (inventoryElement.Key)
								{
									case Resources.Wood:
										<img src="/images/resources/wood.png" width="35" height="35" />
										break;
									case Resources.Brick:
										<img src="/images/resources/brick.png" width="35" height="35" />
										break;
									case Resources.Wheat:
										<img src="/images/resources/wheat.png" width="35" height="35" />
										break;
									case Resources.Ore:
										<img src="/images/resources/ore.png" width="35" height="35" />
										break;
									case Resources.Sheep:
										<img src="/images/resources/sheep.png" width="35" height="35" />
										break;
								}
							</div>
						}
					</div>
				</div>
			</div>
			<div class="col-md-7">
				<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="900" xmlns:xlink="http://www.w3.org/1999/xlink">
					<defs>
						@foreach (var hexagon in hexagons)
						{
							var x = hexagon.Base.X + hexagonSize * Math.Sqrt(3) - 75.5;
							var y = hexagon.Base.Y + hexagonSize - 1;
							switch (hexagon.Field.Type)
							{
								case TerrainType.Desert:
									<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
										<image width="202" height="202" xlink:href="/images/tiles/desert.png"></image>
									</pattern>
									break;
								case TerrainType.Cropfield:
									<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
										<image width="202" height="202" xlink:href="/images/tiles/wheat.png"></image>
									</pattern>
									break;
								case TerrainType.Forest:
									<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
										<image width="202" height="202" xlink:href="/images/tiles/forest.png"></image>
									</pattern>
									break;
								case TerrainType.Mountains:
									<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
										<image width="202" height="202" xlink:href="/images/tiles/mountains.png"></image>
									</pattern>
									break;
								case TerrainType.Quarry:
									<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
										<image width="202" height="202" xlink:href="/images/tiles/quarry.png"></image>
									</pattern>
									break;
								case TerrainType.Grassland:
									<pattern id="@(hexagons.IndexOf(hexagon))" x="@DoubleToString(x)" y="@DoubleToString(y)" height="@(hexagonSize*2)" width="@(hexagonSize*2)" patternUnits="userSpaceOnUse">
										<image width="202" height="202" xlink:href="/images/tiles/grassland.png"></image>
									</pattern>
									break;
							}
						}
					</defs>


					@foreach (var hexagon in hexagons)
					{
						<polygon points=@hexagon.VerticesToString() fill="url('#@hexagons.IndexOf(hexagon)')" 
								@onclick="()=>ClickOnHexagon(hexagon.Field.Id)" stroke="black" stroke-width="1"></polygon>
						@if (hexagon.Field.Type != TerrainType.Desert)
						{
							<circle cx="@DoubleToString(hexagon.Base.X)" cy="@DoubleToString(hexagon.Base.Y)" r="25" fill="beige" />
							<text>
								<text x="@DoubleToString(hexagon.Base.X)" y="@DoubleToString(hexagon.Base.Y+12.5)" font-size="2em"
									  fill="black" text-anchor="middle">@hexagon.Field.Number</text>
							</text>
						}
						@if (hexagon.Field.IsRobbed)
						{
							<circle cx="@DoubleToString(hexagon.Base.X-30)" cy="@DoubleToString(hexagon.Base.Y)" r="15" fill="black" />
						}
					}
					@foreach (var cornerCircle in cornerCircles)
					{
						if (cornerCircle.Corner.Level == 0)
						{
							if (initialVillageTurn || makingSettlement)
							{
								<circle class="cornerCircle" cx="@DoubleToString(cornerCircle.BaseVertex.X)" cy="@DoubleToString(cornerCircle.BaseVertex.Y)" r="10"
							@onclick="()=>ClickOnCornerCircle(cornerCircle.Corner.Id)" fill="black" fill-opacity="0" stroke="green" stroke-width="2" stroke-opacity="0.9" />
							}
							else
							{
								<circle class="cornerCircle" cx="@DoubleToString(cornerCircle.BaseVertex.X)" cy="@DoubleToString(cornerCircle.BaseVertex.Y)" r="10"
							@onclick="()=>ClickOnCornerCircle(cornerCircle.Corner.Id)" fill="black" fill-opacity="0"/>
							}
						}
						if (cornerCircle.Corner.Level == 1)
						{
							if (makingCity)
							{
								<circle class="cornerCircle" cx="@DoubleToString(cornerCircle.BaseVertex.X)" cy="@DoubleToString(cornerCircle.BaseVertex.Y)" r="10"
							@onclick="()=>ClickOnCornerCircle(cornerCircle.Corner.Id)" fill="@cornerCircle.Corner.Player.Color" fill-opacity="1" stroke="green" stroke-width="2" stroke-opacity="0.9" />
							}
							<circle class="cornerCircle" cx="@DoubleToString(cornerCircle.BaseVertex.X)" cy="@DoubleToString(cornerCircle.BaseVertex.Y)" r="10"
							@onclick="()=>ClickOnCornerCircle(cornerCircle.Corner.Id)" fill="@cornerCircle.Corner.Player.Color" fill-opacity="1" stroke="black" stroke-width="2" stroke-opacity="0.9" />
						}
						else if (cornerCircle.Corner.Level == 2)
						{
							<rect x="@DoubleToString(cornerCircle.BaseVertex.X-10)" y="@DoubleToString(cornerCircle.BaseVertex.Y-10)" width="20" height="20"
						  @onclick="()=>ClickOnCornerCircle(cornerCircle.Corner.Id)" fill="@cornerCircle.Corner.Player.Color" fill-opacity="1" stroke="black" stroke-width="2" stroke-opacity="0.9" />
						}
					}
					@foreach (var edgeLine in edgeLines)
					{
						if (edgeLine.Edge.Owner.Name is not null)
						{
							<polygon points=@edgeLine.VerticesToString() fill="@edgeLine.Edge.Owner.Color" fill-opacity="1" stroke="black" stroke-width="1" stroke-opacity="0.9"
							 @onclick="()=>ClickOnEdgeLine(edgeLine.Edge.Id)" />
						}
						else
						{
							if (initialRoadTurn || makingRoad)
							{
								<polygon points=@edgeLine.VerticesToString() fill="black" fill-opacity="0" stroke="green" stroke-width="2" stroke-opacity="0.9"
							 @onclick="()=>ClickOnEdgeLine(edgeLine.Edge.Id)" />
							}
							else
							{
								<polygon points=@edgeLine.VerticesToString() fill="black" fill-opacity="0" @onclick="()=>ClickOnEdgeLine(edgeLine.Edge.Id)" />
							}
						}
					}
				</svg>
			</div>
			<div class="col-md-3">
				<div class="flex-column justify-content-between">
					<div class="m-3 p-3">
						<div id="chatSpace">
							<Chat @ref=ChatComponent />
						</div>
					</div>
					<div class="m-3 p-3">
						<table id="BuildCost" width="100%">
							<tr>
								<td colspan="2" style="text-align:center;">Building Costs</td>
							</tr>
							<tr @onclick="async () => await BuildingRoadClicked()">
								<td> Road:</td>
								<td>
									<img src="/images/resources/wood.png" width="40" height="40" />
									<img src="/images/resources/brick.png" width="40" height="40" />
								</td>
							</tr>
							<tr @onclick="async () => await BuildingSettlementClicked()">
								<td>Settlement:</td>
								<td>
									<img src="/images/resources/wood.png" width="40" height="40" />
									<img src="/images/resources/brick.png" width="40" height="40" />
									<img src="/images/resources/sheep.png" width="40" height="40" />
									<img src="/images/resources/wheat.png" width="40" height="40" />
								</td>
							</tr>
							<tr  @onclick="async () => await BuildingCityClicked()" > 
								<td>City:</td>
								<td>
									<img src="/images/resources/wheat.png" width="40" height="40" />
									<img src="/images/resources/wheat.png" width="40" height="40" />
									<img src="/images/resources/ore.png" width="40" height="40" />
									<img src="/images/resources/ore.png" width="40" height="40" />
									<img src="/images/resources/ore.png" width="40" height="40" />
								</td>
							</tr>
						</table>
					</div>
					<div class="d-flex flex-row-reverse m-3 p-3" style="min-height:100px;">
						@foreach (var dice in dices)
						{
							switch (dice)
							{
								case 1:
									<img src="/images/dice/dice1.png" width="80" height="80" />
									break;
								case 2:
									<img src="/images/dice/dice2.png" width="80" height="80" />
									break;
								case 3:
									<img src="/images/dice/dice3.png" width="80" height="80" />
									break;
								case 4:
									<img src="/images/dice/dice4.png" width="80" height="80" />
									break;
								case 5:
									<img src="/images/dice/dice5.png" width="80" height="80" />
									break;
								case 6:
									<img src="/images/dice/dice6.png" width="80" height="80" />
									break;
							}
						}
					</div>
					<div class="d-flex flex-row-reverse ">
						<div class="p-2">
							<button @onclick="EndTurn" disabled="@(!CanEndTurn())" style="margin:0px;border:0px;padding:0px;"> <img width="50" height="50" src="/images/dice/endturn.png" style="background-color:rgb(250,227,144);" /> </button>
						</div>
						<div class="p-2">
							<button @onclick="RollDice" disabled="@(!CanRollDice())" style="margin:0px;border:0px;padding:0px;"> <img width="50" height="50" src="/images/dice/rolldices.png" style="background-color:rgb(250,227,144);" /> </button>
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>

<p>Hiba: @errorMessage</p>
@code {

	private bool makingSettlement = false; //TODO
	private bool makingRoad = false;
	private bool makingCity = false;

	private bool ownTurn = false;
	private bool diceRolled = false;
	public bool IsConnected =>
		hubConnection?.State == HubConnectionState.Connected;

	private Chat? ChatComponent { get; set; }

	List<Hexagon> hexagons = new List<Hexagon>();

	List<CornerCircle> cornerCircles = new List<CornerCircle>();

	List<EdgeLine> edgeLines = new List<EdgeLine>();

	private int hexagonSize = 100;
	private int hexagonStartingX = 280;
	private int hexagonStartingY = 140;

	private string Guid = "";

	private HubConnection? hubConnection;

	private Map? map;

	private Actor? actor;

	private Dictionary<Resources, int> inventory = new Dictionary<Resources, int>
		{
			{ Resources.Brick, 0 },
			{ Resources.Ore, 0 },
			{ Resources.Sheep, 0 },
			{ Resources.Wheat, 0 },
			{ Resources.Wood, 0 }
		};

	private string CurrentPlayerName = "";
	public void SetYourTurn()
	{
		ownTurn = true;
		diceRolled = false;
		StateHasChanged();
	}

	private async Task BuildingRoadClicked()
	{
		makingRoad=true;
		StateHasChanged();
		await Task.Delay(5000);
		makingRoad=false;
		StateHasChanged();
	}
	private async Task BuildingSettlementClicked()
	{
		makingSettlement = true;
		StateHasChanged();
		await Task.Delay(5000);
		makingSettlement = false;
		StateHasChanged();
	}
	private async Task BuildingCityClicked()
	{
		makingCity = true;
		StateHasChanged();
		await Task.Delay(5000);
		makingCity = false;
		StateHasChanged();
	}

	protected override async Task OnInitializedAsync()
	{
		string name = await JS.InvokeAsync<string>("localStorage.getItem", "userName");
		Guid = await JS.InvokeAsync<string>("localStorage.getItem", "GameGuid");
		string token = await JS.InvokeAsync<string>("localStorage.getItem", "loginToken");
		actor = new Actor(name,token);
		hubConnection = new HubConnectionBuilder()
			.WithUrl(Navigation.ToAbsoluteUri("/gamehub"), options =>
			{
				options.AccessTokenProvider = async () =>
				{
					var token = await JS.InvokeAsync<string>("localStorage.getItem", "loginToken");
					return token;
				};
			})
			.Build();

		SetupHubConnectionEndpoints();

		//Start hub connection
		await hubConnection.StartAsync();
		//Join the correct game group
		await hubConnection.InvokeAsync("JoinGroup", Guid);
		//Setting the connection string at server side
		await SetConnectionString(hubConnection.ConnectionId!);
		//GetMap from server
		var response = await hubConnection!.InvokeAsync<string>("GetMap", Guid, CancellationToken.None);
		await updateMapStatus(response);
		//Change the group of the chat
		await ChatComponent!.ChangeSignalRGroup(Guid);

	}

	private List<Player> PlayerList = new List<Player>();
	private Dictionary<string, int> nameResourceCount = new Dictionary<string, int>();

	private async Task UpdatePlayerList()
	{
		var response = await hubConnection!.InvokeAsync<List<Player>>("GetPlayerList", actor, Guid);
		PlayerList = response;
	}

	private async Task updateMapStatus(string mapstring)
	{
		var options = new JsonSerializerOptions
			{
				MaxDepth = 1000,
				ReferenceHandler = ReferenceHandler.Preserve,
				IncludeFields = true
			};
		map = JsonSerializer.Deserialize<Map>(mapstring, options)!;
		hexagons.Clear();
		cornerCircles.Clear();
		edgeLines.Clear();
		CreateHexagonMap(map.FieldList);
		CreateHexagonEdges();
		CreateCornerCircles();

		await UpdatePlayerList();

		StateHasChanged();
	}
	private string DoubleToString(double d)
	{
		return d.ToString(CultureInfo.InvariantCulture);
	}
	private void CreateHexagonMap(List<Field> fields)
	{
		for (int i = 0; i < 3; i++)
		{
			hexagons.Add(new Hexagon(hexagonStartingX + i * hexagonSize * Math.Sqrt(3), hexagonStartingY, hexagonSize, fields[i]));
		}
		for (int i = 0; i < 4; i++)
		{
			hexagons.Add(new Hexagon(hexagons[0].vertices[2].X + i * hexagonSize * Math.Sqrt(3), hexagons[0].vertices[2].Y + hexagonSize, hexagonSize, fields[i + 3]));
		}
		for (int i = 0; i < 5; i++)
		{
			hexagons.Add(new Hexagon(hexagons[3].vertices[2].X + i * hexagonSize * Math.Sqrt(3), hexagons[3].vertices[2].Y + hexagonSize, hexagonSize, fields[i + 7]));
		}
		for (int i = 0; i < 4; i++)
		{
			hexagons.Add(new Hexagon(hexagons[7].vertices[0].X + i * hexagonSize * Math.Sqrt(3), hexagons[7].vertices[0].Y + hexagonSize, hexagonSize, fields[i + 12]));
		}
		for (int i = 0; i < 3; i++)
		{
			hexagons.Add(new Hexagon(hexagons[12].vertices[0].X + i * hexagonSize * Math.Sqrt(3), hexagons[12].vertices[0].Y + hexagonSize, hexagonSize, fields[i + 16]));
		}
	}
	private void CreateHexagonEdges()
	{
		for (int i = 0; i < hexagons.Count; i++)
		{
			for (int j = 0; j < 6; j++)
			{
				Edge tmpEdge = hexagons[i].Field.Edges[j];
				edgeLines.Add(new EdgeLine(hexagons[i].vertices[j], hexagons[i].vertices[(j + 1) % 6], tmpEdge));
			}
		}
	}
	private void CreateCornerCircles()
	{
		for (int i = 0; i < hexagons.Count; i++)
		{
			for (int j = 0; j < 6; j++)
			{
				Corner tmpCorner = hexagons[i].Field.Corners[j];
				cornerCircles.Add(new CornerCircle(hexagons[i].vertices[j], tmpCorner));
			}
		}
	}
	public async ValueTask DisposeAsync()
	{
		if (hubConnection is not null)
		{
			await hubConnection.DisposeAsync();
		}
	}


	private string errorMessage = "";
	private bool resolveSevenOrMoreResources = false;
	private bool resolveRobberMovement = false;

	private bool initialVillageTurn = false;
	private bool initialRoadTurn = false;
	private void SetupHubConnectionEndpoints()
	{
		hubConnection!.On<string>("ProcessMap", async (mapstring) =>
		{
			await updateMapStatus(mapstring);
		});
		hubConnection!.On("ResolveSevenRoll", () =>
		{
			resolveSevenOrMoreResources = true;
		});
		hubConnection!.On("ResolveRobberMovement", () =>
		{
			resolveRobberMovement = true;
			StateHasChanged();
		});
		hubConnection!.On("RobberMovementResolved", () =>
		{
			resolveRobberMovement = false;
			StateHasChanged();
		});
		hubConnection!.On("InitialTurnDone", () =>
		{
			initialRoadTurn = false;
			StateHasChanged();
		});
		hubConnection!.On("PlaceInitialVillage", () =>
		{
			initialVillageTurn = true;
			StateHasChanged();
		});
		hubConnection!.On("PlaceInitialRoad", () =>
		{
			initialRoadTurn = true;
			initialVillageTurn = false;
			StateHasChanged();
		});
		hubConnection!.On("TakeNormalTurn", () =>
		{
			diceRolled = false;
			ownTurn = true;
			StateHasChanged();
		});
		hubConnection!.On<string>("ProcessCurrentPlayer", name =>
		{
			CurrentPlayerName = name;
			StateHasChanged();
		});

		hubConnection!.On<string>("ProcessErrorMessage", message =>
		{
			errorMessage = message;
			StateHasChanged();
		});

		hubConnection!.On("FetchResources", async () =>
		{
			var response = await hubConnection!.InvokeAsync<FetchInventoryDTO>("GetPlayersInventories", actor, Guid);
			foreach (var dictionaryItem in response.Inventory)
			{
				inventory[dictionaryItem.Key] = dictionaryItem.Value;
			}
			nameResourceCount = response.OthersInventory;
			StateHasChanged();
		});

		hubConnection!.On<int[]>("ProcessDiceRolled", rollResult =>
		{
			var sum = (rollResult[0] + rollResult[1]).ToString();
			dices[0] = rollResult[0];
			dices[1] = rollResult[1];
			if (ChatComponent is not null)
			{
				ChatComponent.SendDebugMessage("Result of the dice roll: " + sum);
			}
			StateHasChanged();
		});
		hubConnection!.On("DiceRolled", () =>
		{
			diceRolled = true;
			StateHasChanged();
		});
		hubConnection!.On("TurnEnded", () =>
		{
			ownTurn = false;
			StateHasChanged();
		});
		hubConnection!.On("GameOver", () =>
		{
			//TODO
		});

	}
	private int[] dices = new int[2];
	private async Task SetConnectionString(string conID)
	{
		await hubConnection!.SendAsync("SaveConnectionId", actor, conID, Guid);
	}
	private async Task RollDice()
	{
		await hubConnection!.SendAsync("RollDices", actor, Guid);
	}
	private async Task EndTurn()
	{
		await hubConnection!.SendAsync("EndPlayerTurn", actor, Guid);
	}
	private async Task ClickOnCornerCircle(int id)
	{
		if (initialVillageTurn)
		{
			await hubConnection!.SendAsync("ClaimInitialVillage", actor, Guid, id);
		}
		else if (ownTurn)
		{
			await hubConnection!.SendAsync("ClaimCorner", actor, Guid, id);
		}
		StateHasChanged();
	}
	private async Task ClickOnEdgeLine(int id)
	{
		if (initialRoadTurn)
		{
			await hubConnection!.SendAsync("ClaimInitialRoad", actor, Guid, id);
		}
		else if (ownTurn)
		{
			await hubConnection!.SendAsync("ClaimEdge", actor, Guid, id);
		}
		StateHasChanged();
	}

	private async Task ClickOnHexagon(int id)
	{
		if (ownTurn && resolveRobberMovement)
		{
			await hubConnection!.SendAsync("MoveRobber", actor, Guid, id);
		}
	}
	private bool CanRollDice()
	{
		if (diceRolled)
		{
			return false;
		}
		if (ownTurn)
		{
			return true;
		}
		return false;
	}
	private bool CanEndTurn()
	{
		if (!diceRolled)
		{
			return false;
		}
		if (resolveSevenOrMoreResources || resolveRobberMovement)
		{
			return false;
		}
		if (ownTurn)
		{
			return true;
		}
		return false;
	}
}